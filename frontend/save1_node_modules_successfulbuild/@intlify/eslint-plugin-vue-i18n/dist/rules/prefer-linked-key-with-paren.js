"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = require("path");
const index_1 = require("../utils/index");
const debug_1 = __importDefault(require("debug"));
const utils_1 = require("../utils/message-compiler/utils");
const parser_1 = require("../utils/message-compiler/parser");
const parser_v8_1 = require("../utils/message-compiler/parser-v8");
const traverser_1 = require("../utils/message-compiler/traverser");
const rule_1 = require("../utils/rule");
const debug = (0, debug_1.default)('eslint-plugin-vue-i18n:prefer-linked-key-with-paren');
function getSingleQuote(node) {
    if (node.type === 'JSONLiteral') {
        return node.raw[0] !== "'" ? "'" : "\\'";
    }
    if (node.style === 'single-quoted') {
        return "''";
    }
    return "'";
}
function create(context) {
    const filename = context.getFilename();
    const sourceCode = context.getSourceCode();
    const messageSyntaxVersions = (0, utils_1.getMessageSyntaxVersions)(context);
    function verifyForV9(message, reportNode, getReportOffset) {
        const { ast, errors } = (0, parser_1.parse)(message);
        if (errors.length) {
            return;
        }
        (0, traverser_1.traverseNode)(ast, node => {
            if (node.type !== utils_1.NodeTypes.LinkedKey) {
                return;
            }
            let range = null;
            const start = getReportOffset(node.loc.start.offset);
            const end = getReportOffset(node.loc.end.offset);
            if (start != null && end != null) {
                range = [start, end];
            }
            context.report({
                loc: range
                    ? {
                        start: sourceCode.getLocFromIndex(range[0]),
                        end: sourceCode.getLocFromIndex(range[1])
                    }
                    : reportNode.loc,
                message: 'The linked message key must be enclosed in brackets.',
                fix(fixer) {
                    if (!range) {
                        return null;
                    }
                    const single = getSingleQuote(reportNode);
                    return [
                        fixer.insertTextBeforeRange(range, `{${single}`),
                        fixer.insertTextAfterRange(range, `${single}}`)
                    ];
                }
            });
        });
    }
    function verifyForV8(message, reportNode, getReportOffset) {
        const { ast, errors } = (0, parser_v8_1.parse)(message);
        if (errors.length) {
            return;
        }
        (0, traverser_1.traverseNode)(ast, node => {
            if (node.type !== utils_1.NodeTypes.LinkedKey) {
                return;
            }
            if (message[node.loc.start.offset - 1] === '(') {
                return;
            }
            let range = null;
            const start = getReportOffset(node.loc.start.offset);
            const end = getReportOffset(node.loc.end.offset);
            if (start != null && end != null) {
                range = [start, end];
            }
            context.report({
                loc: range
                    ? {
                        start: sourceCode.getLocFromIndex(range[0]),
                        end: sourceCode.getLocFromIndex(range[1])
                    }
                    : reportNode.loc,
                message: 'The linked message key must be enclosed in parentheses.',
                fix(fixer) {
                    if (!range) {
                        return null;
                    }
                    return [
                        fixer.insertTextBeforeRange(range, '('),
                        fixer.insertTextAfterRange(range, ')')
                    ];
                }
            });
        });
    }
    function verifyMessage(message, reportNode, getReportOffset) {
        if (messageSyntaxVersions.reportIfMissingSetting()) {
            return;
        }
        if (messageSyntaxVersions.v9 && messageSyntaxVersions.v8) {
            return;
        }
        if (messageSyntaxVersions.v9) {
            verifyForV9(message, reportNode, getReportOffset);
        }
        else if (messageSyntaxVersions.v8) {
            verifyForV8(message, reportNode, getReportOffset);
        }
    }
    function createVisitorForJson() {
        function verifyExpression(node) {
            if (node.type !== 'JSONLiteral' || typeof node.value !== 'string') {
                return;
            }
            verifyMessage(node.value, node, offset => (0, utils_1.getReportIndex)(node, offset));
        }
        return {
            JSONProperty(node) {
                verifyExpression(node.value);
            },
            JSONArrayExpression(node) {
                for (const element of node.elements) {
                    if (element)
                        verifyExpression(element);
                }
            }
        };
    }
    function createVisitorForYaml() {
        const yamlKeyNodes = new Set();
        function withinKey(node) {
            for (const keyNode of yamlKeyNodes) {
                if (keyNode.range[0] <= node.range[0] &&
                    node.range[0] < keyNode.range[1]) {
                    return true;
                }
            }
            return false;
        }
        function verifyContent(node) {
            const valueNode = node.type === 'YAMLWithMeta' ? node.value : node;
            if (!valueNode ||
                valueNode.type !== 'YAMLScalar' ||
                typeof valueNode.value !== 'string') {
                return;
            }
            verifyMessage(valueNode.value, valueNode, offset => (0, utils_1.getReportIndex)(valueNode, offset));
        }
        return {
            YAMLPair(node) {
                if (withinKey(node)) {
                    return;
                }
                if (node.key != null) {
                    yamlKeyNodes.add(node.key);
                }
                if (node.value)
                    verifyContent(node.value);
            },
            YAMLSequence(node) {
                if (withinKey(node)) {
                    return;
                }
                for (const entry of node.entries) {
                    if (entry)
                        verifyContent(entry);
                }
            }
        };
    }
    if ((0, path_1.extname)(filename) === '.vue') {
        return (0, index_1.defineCustomBlocksVisitor)(context, createVisitorForJson, createVisitorForYaml);
    }
    else if (context.parserServices.isJSON || context.parserServices.isYAML) {
        const localeMessages = (0, index_1.getLocaleMessages)(context);
        const targetLocaleMessage = localeMessages.findExistLocaleMessage(filename);
        if (!targetLocaleMessage) {
            debug(`ignore ${filename} in prefer-linked-key-with-paren`);
            return {};
        }
        if (context.parserServices.isJSON) {
            return createVisitorForJson();
        }
        else if (context.parserServices.isYAML) {
            return createVisitorForYaml();
        }
        return {};
    }
    else {
        debug(`ignore ${filename} in prefer-linked-key-with-paren`);
        return {};
    }
}
module.exports = (0, rule_1.createRule)({
    meta: {
        type: 'layout',
        docs: {
            description: 'enforce linked key to be enclosed in parentheses',
            category: 'Stylistic Issues',
            url: 'https://eslint-plugin-vue-i18n.intlify.dev/rules/prefer-linked-key-with-paren.html',
            recommended: false
        },
        fixable: 'code',
        schema: []
    },
    create
});
